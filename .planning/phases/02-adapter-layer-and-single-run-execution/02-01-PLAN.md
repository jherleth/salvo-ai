---
phase: 02-adapter-layer-and-single-run-execution
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/salvo/adapters/__init__.py
  - src/salvo/adapters/base.py
  - src/salvo/adapters/registry.py
  - src/salvo/execution/__init__.py
  - src/salvo/execution/cost.py
  - src/salvo/execution/extras.py
  - tests/test_adapters_base.py
  - tests/test_adapters_registry.py
  - tests/test_execution_cost.py
  - tests/test_execution_extras.py
autonomous: true
requirements:
  - ADPT-03
  - EXEC-04

must_haves:
  truths:
    - "A custom adapter class that subclasses BaseAdapter and implements send_turn() can be instantiated"
    - "A custom adapter class missing send_turn() cannot be instantiated (TypeError)"
    - "get_adapter('openai') returns the correct dotted path lookup (lazy import)"
    - "get_adapter('my.module.MyAdapter') loads a custom adapter by dotted path"
    - "estimate_cost returns a float for known models and None for unknown models"
    - "Extras validation rejects dicts containing secret-like keys and oversized payloads"
  artifacts:
    - path: "src/salvo/adapters/base.py"
      provides: "BaseAdapter ABC, Message, AdapterTurnResult, TokenUsage, ToolCallResult, AdapterConfig dataclasses"
      contains: "class BaseAdapter(ABC)"
    - path: "src/salvo/adapters/registry.py"
      provides: "get_adapter() function with builtin name lookup and dotted-path import"
      exports: ["get_adapter"]
    - path: "src/salvo/execution/cost.py"
      provides: "estimate_cost() function with static pricing table"
      exports: ["estimate_cost"]
    - path: "src/salvo/execution/extras.py"
      provides: "validate_extras() function with blocklist and size limits"
      exports: ["validate_extras"]
  key_links:
    - from: "src/salvo/adapters/registry.py"
      to: "src/salvo/adapters/base.py"
      via: "isinstance check against BaseAdapter"
      pattern: "issubclass.*BaseAdapter"
    - from: "src/salvo/adapters/registry.py"
      to: "importlib"
      via: "dynamic module import for custom adapters"
      pattern: "importlib\\.import_module"
---

<objective>
Create the adapter foundation layer: BaseAdapter abstract base class with unified message types, adapter registry for name-based and dotted-path lookup, cost estimation from token usage, and extras validation with security guardrails.

Purpose: These types and utilities are the foundation for all provider adapters, the execution runner, and the CLI. Nothing in Phase 2 can function without them.
Output: Four modules (adapters/base.py, adapters/registry.py, execution/cost.py, execution/extras.py) with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-adapter-layer-and-single-run-execution/02-RESEARCH.md
@src/salvo/models/scenario.py
@src/salvo/models/result.py
@src/salvo/models/__init__.py
</context>

<tasks>

<task type="tdd">
  <name>Task 1: BaseAdapter ABC, unified message types, and adapter registry</name>
  <files>
    src/salvo/adapters/__init__.py
    src/salvo/adapters/base.py
    src/salvo/adapters/registry.py
    tests/test_adapters_base.py
    tests/test_adapters_registry.py
  </files>
  <action>
    **TDD: Write tests first (RED), then implement (GREEN).**

    **Expected behavior (write tests for these):**

    BaseAdapter ABC with single abstract method `send_turn(messages, tools, config) -> AdapterTurnResult`:
    1. BaseAdapter cannot be instantiated directly (TypeError)
    2. A subclass implementing send_turn() CAN be instantiated
    3. A subclass missing send_turn() cannot be instantiated (TypeError)
    4. provider_name() returns class name by default

    Dataclasses (NOT Pydantic -- avoid overhead in hot path):
    - ToolCallResult: id (str), name (str), arguments (dict[str, Any])
    - TokenUsage: input_tokens (int, default 0), output_tokens (int, default 0), total_tokens (int, default 0)
    - AdapterTurnResult: content (str | None), tool_calls (list[ToolCallResult]), usage (TokenUsage), raw_response (dict), finish_reason (str)
    - Message: role (str: system/user/assistant/tool_call/tool_result), content (str | None), tool_calls (list[ToolCallResult] | None), tool_call_id (str | None), tool_name (str | None)
    - AdapterConfig: model (str), temperature (float | None), max_tokens (int | None), seed (int | None), extras (dict[str, Any])

    Adapter registry (get_adapter function):
    - get_adapter("openai") -> resolves to "salvo.adapters.openai_adapter.OpenAIAdapter" (lazy import, will fail with ImportError if openai package not installed)
    - get_adapter("anthropic") -> resolves to "salvo.adapters.anthropic_adapter.AnthropicAdapter" (lazy import)
    - get_adapter("my.module.MyAdapter") -> imports module "my.module", gets class "MyAdapter", validates issubclass(BaseAdapter), returns instance
    - get_adapter("unknown") -> raises ValueError with helpful message listing available builtin adapters
    - get_adapter("dotted.path.NotABaseAdapter") -> raises TypeError if not a BaseAdapter subclass

    Test cases:
    - test_cannot_instantiate_base_adapter
    - test_subclass_with_send_turn_instantiates
    - test_subclass_without_send_turn_raises
    - test_provider_name_default
    - test_dataclass_defaults (TokenUsage, AdapterTurnResult, Message, AdapterConfig)
    - test_get_adapter_builtin_openai_fails_without_sdk (ImportError with install hint)
    - test_get_adapter_custom_dotted_path (create a test adapter in tests/)
    - test_get_adapter_unknown_name
    - test_get_adapter_not_subclass_raises_type_error

    **Implementation (after tests are written):**
    1. Create src/salvo/adapters/base.py with all dataclasses and BaseAdapter ABC using `from __future__ import annotations`, `abc.ABC`, `abc.abstractmethod`, and `dataclasses.dataclass`/`field`.
    2. Create src/salvo/adapters/registry.py with BUILTIN_ADAPTERS dict mapping "openai" and "anthropic" to their dotted paths. get_adapter() does: lookup name in BUILTIN_ADAPTERS (or use name itself as dotted path), rpartition(".") to split module and class, importlib.import_module(), getattr(), issubclass check, return cls().
    3. Create src/salvo/adapters/__init__.py re-exporting BaseAdapter, all dataclasses, and get_adapter.
    4. For the test of custom dotted-path loading, create a simple test adapter class inside the test file and mock importlib.import_module to return a module containing it.
    5. When a builtin adapter fails to import, check if the name is in BUILTIN_ADAPTERS and provide a specific error: "Adapter 'openai' requires the openai package. Install it: pip install salvo-ai[openai]"
  </action>
  <verify>
    cd /Users/apple/JHERLETH/agent-something && .venv/bin/python -m pytest tests/test_adapters_base.py tests/test_adapters_registry.py -v
  </verify>
  <done>
    BaseAdapter ABC prevents direct instantiation, subclasses with send_turn() work, registry resolves builtin names and dotted paths, clear error messages for missing SDKs and unknown adapters.
  </done>
</task>

<task type="tdd">
  <name>Task 2: Cost estimation and extras validation</name>
  <files>
    src/salvo/execution/__init__.py
    src/salvo/execution/cost.py
    src/salvo/execution/extras.py
    tests/test_execution_cost.py
    tests/test_execution_extras.py
  </files>
  <action>
    **TDD: Write tests first (RED), then implement (GREEN).**

    **Expected behavior (write tests for these):**

    Cost estimation (estimate_cost function):
    - estimate_cost("gpt-4o", 1000, 500) -> calculates: (1000/1M * 2.50) + (500/1M * 10.00) = 0.0025 + 0.005 = 0.0075
    - estimate_cost("gpt-4o-mini", 1000, 500) -> (1000/1M * 0.15) + (500/1M * 0.60) = 0.00015 + 0.0003 = 0.00045
    - estimate_cost("claude-sonnet-4-5", 1000, 500) -> (1000/1M * 3.00) + (500/1M * 15.00) = 0.003 + 0.0075 = 0.0105
    - estimate_cost("claude-haiku-4-5", 1000, 500) -> (1000/1M * 1.00) + (500/1M * 5.00) = 0.001 + 0.0025 = 0.0035
    - estimate_cost("unknown-model", 1000, 500) -> None
    - estimate_cost("gpt-4o", 0, 0) -> 0.0

    Static pricing table (ModelPricing dataclass with input_per_million, output_per_million):
    - gpt-4o: $2.50 / $10.00
    - gpt-4o-mini: $0.15 / $0.60
    - claude-sonnet-4-5: $3.00 / $15.00 (also claude-sonnet-4-5-20250929)
    - claude-haiku-4-5: $1.00 / $5.00 (also claude-haiku-4-5-20241022)

    Extras validation (validate_extras function):
    - validate_extras({"response_format": {"type": "text"}}) -> returns validated dict (passthrough)
    - validate_extras({"api_key": "sk-xxx"}) -> raises ValueError (blocked key)
    - validate_extras({"token": "abc"}) -> raises ValueError (blocked key)
    - validate_extras({"password": "abc"}) -> raises ValueError (blocked key)
    - validate_extras({"authorization": "Bearer xxx"}) -> raises ValueError (blocked key)
    - validate_extras({"api_secret": "xxx"}) -> raises ValueError (blocked key)
    - validate_extras({"a" * i: "v" for i in range(20)}) -> raises ValueError if > 10 keys
    - validate_extras with total serialized size > 4096 bytes -> raises ValueError
    - validate_extras({}) -> returns {} (empty is valid)

    Blocklist (case-insensitive matching): api_key, api_secret, secret, token, password, authorization, secret_key, access_token, refresh_token

    Test cases:
    - test_estimate_cost_gpt4o
    - test_estimate_cost_gpt4o_mini
    - test_estimate_cost_claude_sonnet
    - test_estimate_cost_claude_haiku
    - test_estimate_cost_unknown_model_returns_none
    - test_estimate_cost_zero_tokens
    - test_estimate_cost_model_aliases (dated versions)
    - test_validate_extras_passthrough
    - test_validate_extras_blocks_api_key
    - test_validate_extras_blocks_token
    - test_validate_extras_blocks_password
    - test_validate_extras_case_insensitive
    - test_validate_extras_too_many_keys
    - test_validate_extras_too_large
    - test_validate_extras_empty_dict

    **Implementation (after tests are written):**
    1. Create src/salvo/execution/cost.py with ModelPricing dataclass and PRICING_TABLE dict. estimate_cost(model, input_tokens, output_tokens) -> float | None. Round to 6 decimal places.
    2. Create src/salvo/execution/extras.py with BLOCKED_KEYS set (case-insensitive), MAX_EXTRAS_KEYS = 10, MAX_EXTRAS_SIZE = 4096. validate_extras(extras: dict) -> dict. Check: keys against blocklist (case-insensitive), key count, serialized size via json.dumps. Raise ValueError with descriptive messages.
    3. Create src/salvo/execution/__init__.py re-exporting estimate_cost and validate_extras.
  </action>
  <verify>
    cd /Users/apple/JHERLETH/agent-something && .venv/bin/python -m pytest tests/test_execution_cost.py tests/test_execution_extras.py -v
  </verify>
  <done>
    Cost estimation returns correct USD amounts for all 4 supported models (and aliases), returns None for unknown models. Extras validation blocks secret-like keys, enforces key count and size limits, passes through valid dicts.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/apple/JHERLETH/agent-something && .venv/bin/python -m pytest tests/test_adapters_base.py tests/test_adapters_registry.py tests/test_execution_cost.py tests/test_execution_extras.py -v
```

All tests pass. BaseAdapter ABC enforces the contract. Registry resolves builtins and custom adapters. Cost estimation covers all supported models. Extras validation blocks secrets.
</verification>

<success_criteria>
1. BaseAdapter ABC cannot be instantiated; subclasses with send_turn() can
2. get_adapter() resolves "openai", "anthropic" (with clear import errors), and custom dotted paths
3. estimate_cost() returns correct amounts for gpt-4o, gpt-4o-mini, claude-sonnet-4-5, claude-haiku-4-5 and None for unknown models
4. validate_extras() blocks secret keys, enforces limits, passes valid dicts
5. All new tests pass alongside existing Phase 1 tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-adapter-layer-and-single-run-execution/02-01-SUMMARY.md`
</output>
